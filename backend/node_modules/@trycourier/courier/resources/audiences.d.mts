import { APIResource } from "../core/resource.mjs";
import * as Shared from "./shared.mjs";
import { APIPromise } from "../core/api-promise.mjs";
import { RequestOptions } from "../internal/request-options.mjs";
export declare class Audiences extends APIResource {
    /**
     * Returns the specified audience by id.
     */
    retrieve(audienceID: string, options?: RequestOptions): APIPromise<Audience>;
    /**
     * Creates or updates audience.
     */
    update(audienceID: string, body: AudienceUpdateParams, options?: RequestOptions): APIPromise<AudienceUpdateResponse>;
    /**
     * Get the audiences associated with the authorization token.
     */
    list(query?: AudienceListParams | null | undefined, options?: RequestOptions): APIPromise<AudienceListResponse>;
    /**
     * Deletes the specified audience.
     */
    delete(audienceID: string, options?: RequestOptions): APIPromise<void>;
    /**
     * Get list of members of an audience.
     */
    listMembers(audienceID: string, query?: AudienceListMembersParams | null | undefined, options?: RequestOptions): APIPromise<AudienceListMembersResponse>;
}
export interface Audience {
    /**
     * A unique identifier representing the audience_id
     */
    id: string;
    created_at: string;
    /**
     * A description of the audience
     */
    description: string;
    /**
     * A single filter to use for filtering
     */
    filter: Filter;
    /**
     * The name of the audience
     */
    name: string;
    updated_at: string;
}
export interface Filter {
    /**
     * The operator to use for filtering
     */
    operator: 'ENDS_WITH' | 'EQ' | 'EXISTS' | 'GT' | 'GTE' | 'INCLUDES' | 'IS_AFTER' | 'IS_BEFORE' | 'LT' | 'LTE' | 'NEQ' | 'OMIT' | 'STARTS_WITH' | 'AND' | 'OR';
    /**
     * The attribe name from profile whose value will be operated against the filter
     * value
     */
    path: string;
    /**
     * The value to use for filtering
     */
    value: string;
}
export interface FilterConfig {
    /**
     * The operator to use for filtering
     */
    operator: 'ENDS_WITH' | 'EQ' | 'EXISTS' | 'GT' | 'GTE' | 'INCLUDES' | 'IS_AFTER' | 'IS_BEFORE' | 'LT' | 'LTE' | 'NEQ' | 'OMIT' | 'STARTS_WITH' | 'AND' | 'OR';
    /**
     * The attribe name from profile whose value will be operated against the filter
     * value
     */
    path: string;
    /**
     * The value to use for filtering
     */
    value: string;
}
export interface AudienceUpdateResponse {
    audience: Audience;
}
export interface AudienceListResponse {
    items: Array<Audience>;
    paging: Shared.Paging;
}
export interface AudienceListMembersResponse {
    items: Array<AudienceListMembersResponse.Item>;
    paging: Shared.Paging;
}
export declare namespace AudienceListMembersResponse {
    interface Item {
        added_at: string;
        audience_id: string;
        audience_version: number;
        member_id: string;
        reason: string;
    }
}
export interface AudienceUpdateParams {
    /**
     * A description of the audience
     */
    description?: string | null;
    /**
     * A single filter to use for filtering
     */
    filter?: Filter | null;
    /**
     * The name of the audience
     */
    name?: string | null;
}
export interface AudienceListParams {
    /**
     * A unique identifier that allows for fetching the next set of audiences
     */
    cursor?: string | null;
}
export interface AudienceListMembersParams {
    /**
     * A unique identifier that allows for fetching the next set of members
     */
    cursor?: string | null;
}
export declare namespace Audiences {
    export { type Audience as Audience, type Filter as Filter, type FilterConfig as FilterConfig, type AudienceUpdateResponse as AudienceUpdateResponse, type AudienceListResponse as AudienceListResponse, type AudienceListMembersResponse as AudienceListMembersResponse, type AudienceUpdateParams as AudienceUpdateParams, type AudienceListParams as AudienceListParams, type AudienceListMembersParams as AudienceListMembersParams, };
}
//# sourceMappingURL=audiences.d.mts.map